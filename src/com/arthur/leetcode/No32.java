package com.arthur.leetcode;

import com.sun.org.apache.xalan.internal.xsltc.dom.SAXImpl;

import javax.swing.plaf.basic.BasicInternalFrameTitlePane;

/**
 * @title: No32
 * @Author ArthurJi
 * @Date: 2021/4/15 13:24
 * @Version 1.0
 */
public class No32 {
    public int longestValidParentheses(String s) {

        int maxLen = 0;
        int length = s.length();
        int[] dp = new int[length];
        for (int i = 1; i < length; i++) {
            if (s.charAt(i) == ')') {
                if (s.charAt(i - 1) == '(') {
                    if (i < 2) {
                        dp[i] = 2;
                    } else {
                        dp[i] = dp[i - 2] + 2;
                    }
                } else {
                    int preIndex = i - dp[i - 1] - 1;
                    if (preIndex >= 0) {
                        if (s.charAt(preIndex) == '(') {
                            dp[i] = dp[i - 1] + 2;
                            if(preIndex - 1 >= 0) {
                                dp[i] += dp[preIndex - 1];
                            }
                        }
                    }
                }
            }
            maxLen = Math.max(maxLen, dp[i]);
        }
        return maxLen;

    }

}
/*
32. 最长有效括号
        给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。



        示例 1：

        输入：s = "(()"
        输出：2
        解释：最长有效括号子串是 "()"
        示例 2：

        输入：s = ")()())"
        输出：4
        解释：最长有效括号子串是 "()()"
        示例 3：

        输入：s = ""
        输出：0*/

/*
动态规划思路详解（c++）——32.最长有效括号
        zhanganan0425
        发布于 2020-04-17
        20.8k
        解题思路：
        结合题目，有最长这个字眼，可以考虑尝试使用 动态规划 进行分析。这是一个 最值型 动态规划的题目。

        动态规划题目分析的 4 个步骤：

        确定状态
        研究最优策略的最后一步
        化为子问题
        转移方程
        根据子问题定义得到
        初始条件和边界情况
        计算顺序
        首先，我们定义一个 dpdp 数组，其中第 ii 个元素表示以下标为 ii 的字符结尾的最长有效子字符串的长度。

        确定状态：
        最后一步：
        对于最优的策略，一定有最后一个元素 s[i]s[i].

        所以，我们先看第 ii 个位置，这个位置的元素 s[i]s[i]可能有如下两种情况：

        s[i] == '('s[i]==
        ′
        (
        ′
        :

        这时，s[i]s[i] 无法和其之前的元素组成有效的括号对，所以，dp[i] = 0dp[i]=0

        s[i] == ')'s[i]==
        ′
        )
        ′
        :

        这时，需要看其前面对元素来判断是否有有效括号对。

        情况1:

        s[i - 1] == '('s[i−1]==
        ′
        (
        ′


        即 s[i]s[i] 和 s[i - 1]s[i−1] 组成一对有效括号，有效括号长度新增长度2，ii位置对最长有效括号长度为 其之前2个位置的最长括号长度加上当前位置新增的2，我们无需知道i-2i−2位置对字符是否可以组成有效括号对。

        那么有：

        dp[i] = dp[i - 2] + 2dp[i]=dp[i−2]+2

        截屏2020-04-17下午4.30.46.png

        情况2:

        s[i - 1] == ')'s[i−1]==
        ′
        )
        ′


        这种情况下，如果前面有和s[i]s[i]组成有效括号对的字符，即形如( (....) )((....))，这样的话，就要求s[i - 1]s[i−1]位置必然是有效的括号对，否则s[i]s[i]无法和前面对字符组成有效括号对。

        这时，我们只需要找到和s[i]s[i]配对对位置，并判断其是否是 (( 即可。和其配对对位置为：i - dp[i - 1] - 1i−dp[i−1]−1。

        如果：s[i - dp[i - 1] - 1] == '('s[i−dp[i−1]−1]==
        ′
        (
        ′
        :

        有效括号长度新增长度2，ii位置对最长有效括号长度为 i-1位置的最长括号长度加上当前位置新增的2，那么有：

        dp[i] = dp[i - 1] + 2dp[i]=dp[i−1]+2

        值得注意的是，i - dp[i - 1] - 1i−dp[i−1]−1 和 ii 组成了有效括号对，这将是一段独立的有效括号序列，如果之前的子序列是形如 (...)(...) 这种序列，那么当前位置的最长有效括号长度还需要加上这一段。所以：

        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2

        注： 这个在分析时是很容易遗漏的，分析要更细致。我在第一次分析是就遗漏了，提交后，有用例 )()(()))不过，分析后发现是少了这一段。

        截屏2020-04-17下午4.26.34.png

        子问题：
        根据上面的分析，我们得到了如下两个计算公式：

        dp[i] = dp[i - 2] + 2dp[i]=dp[i−2]+2

        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2

        那么，求dp[i]dp[i]就变成了求dp[i - 1]dp[i−1]、 dp[i - 2]dp[i−2]、dp[i - dp[i - 1] - 2]dp[i−dp[i−1]−2]的子问题。

        这样状态也明确了：

        设dpdp 数组，其中第 ii 个元素表示以下标为 ii 的字符结尾的最长有效子字符串的长度。

        转移方程：
        子问题明确后，转移方程直接由子问题得到：


        if s[i] == '(' :
        dp[i] = 0
        if s[i] == ')' :
        if s[i - 1] == '(' :
        dp[i] = dp[i - 2] + 2 #要保证i - 2 >= 0

        if s[i - 1] == ')' and s[i - dp[i - 1] - 1] == '(' :
        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2 #要保证i - dp[i - 1] - 2 >= 0
        初始条件和边界情况：
        初始条件： dp[i] = 0dp[i]=0

        边界情况：需要保证计算过程中：i - 2 >= 0i−2>=0 和 i - dp[i - 1] - 2 >= 0i−dp[i−1]−2>=0

        计算顺序：
        无论第一个字符是什么，都有：dp[0] = 0dp[0]=0

        然后依次计算：dp[1], dp[2], ..., dp[n - 1]dp[1],dp[2],...,dp[n−1]

        结果是： max(dp[i])max(dp[i])

        复杂度计算：
        时间复杂度： 遍历了一遍字符串，所以时间复杂度是：O(N)O(N)

        空间复杂度：需要和字符串长度相同的数组保存每个位置的最长有效括号长度，所以空间复杂度是：O(N)O(N)


class Solution {
    public:
    int longestValidParentheses(string s) {
        int size = s.length();
        vector<int> dp(size, 0);

        int maxVal = 0;
        for(int i = 1; i < size; i++) {
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    dp[i] = 2;
                    if (i - 2 >= 0) {
                        dp[i] = dp[i] + dp[i - 2];
                    }
                } else if (dp[i - 1] > 0) {
                    if ((i - dp[i - 1] - 1) >= 0 && s[i - dp[i - 1] - 1] == '(') {
                        dp[i] = dp[i - 1] + 2;
                        if ((i - dp[i - 1] - 2) >= 0) {
                            dp[i] = dp[i] + dp[i - dp[i - 1] - 2];
                        }
                    }
                }
            }
            maxVal = max(maxVal, dp[i]);
        }
        return maxVal;
    }
};
总结
        拿到这种题目后，不要慌，根据题目中是否有：计数、最大/最小/最长、是否存在等字眼，先判断是否可以使用动态规划解决，如果可以，然后根据上面的步骤，一步一步进行分析，尤其是最后一步这一步分析，是能否转化为子问题的关键。转化为子问题后，就能轻易得到转移方程，后面的操作就简单了。

        有些题目，动态规划不一定是最高效的解法，但是根据这个套路进行分析，一定是最快的解法。先写出来之后再考虑是否可以优化，或者其他更优的解法。

        下一篇：最长有效括号*/
